---
title: leetcode-车的可用捕获量
categories:
  - 算法
tags:
  - leetcode
abbrlink: 58297
date: 2020-03-26 22:05:56
---

## 题目

在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。

## 示例

![车的可用捕获量](https://blog-images-1252854786.cos.ap-guangzhou.myqcloud.com/imgs/algorithm/%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F1)
输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。

![](https://blog-images-1252854786.cos.ap-guangzhou.myqcloud.com/imgs/algorithm/%E8%BD%A6%E7%9A%84%E6%8D%95%E8%8E%B7%E9%87%8F2)
输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。

![](https://blog-images-1252854786.cos.ap-guangzhou.myqcloud.com/imgs/algorithm/%E8%BD%A6%E7%9A%84%E6%8D%95%E8%8E%B7%E9%87%8F3)

输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：
象阻止了车捕获任何卒。

## 解题思路
1. 首先肯定要找到存在R的数组，然后让这个坐标像前后左右走，遇到p就加1并结束循环
遇到B也结束循环

2. 找到这个R的坐标，现在有R的数组中找到可以直接到p的，然后在其他数组中找到相同下边的值做成一个数组，继续找p

## 代码
```js
var numRookCaptures = function(board) {
    let result = 0
    let R = []
    let width = board[0].length
    let height = board.length
    for(let i = 0; i < height; i++) {
        for(let j = 0; j< width; j++){
            if(board[i][j] === 'R') {
                R = [i, j] 
            }
        }
    }
    console.log(R)
    // 然后向四个方向走
    for(let j = R[1]; j< width; j++){
        if(board[R[0]][j] === 'B') {
            break
        }
        if(board[R[0]][j] === 'p') {
            result += 1
            break
        }
    }
    for(let j = R[1]; j> -1; j--){
        if(board[R[0]][j] === 'B') {
            break
        }
        if(board[R[0]][j] === 'p') {
            result += 1
            break
        }
    }
    for(let j = R[0]; j< height; j++){
        if(board[j][R[1]] === 'B') {
            break
        }
        if(board[j][R[1]] === 'p') {
            result += 1
            break
        }
    }
    for(let j = R[0]; j> -1; j--){
        if(board[j][R[1]] === 'B') {
            break
        }
        if(board[j][R[1]] === 'p') {
            result += 1
            break
        }
    }
    return result
};

```