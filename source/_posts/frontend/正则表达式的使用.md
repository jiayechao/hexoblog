---
title: 正则表达式的使用
date: 2019-10-29 11:06:34
categories:
- 前端基础
tags: 
- 正则
- RegExp
---

## 元字符

常用的<font color="red">*元字符*</font>

|  字符   | 描述 |
|  ----  | ----  |
|  .  | 匹配除换行符以外的任意字符  |
|  \  | 转义字符  |
|  \d  | 匹配数字  |
|  \w  | 匹配字母或数字或下划线或汉字  |
|  \s  | 匹配任意的空白符  |
|  \b  | 匹配单词的开始或结束  |
|  ^  | 匹配字符串的开始  |
|  $  | 匹配字符串的结束  |

## 反义

|  字符   | 描述 |
|  ----  | ----  |
|  \B  | 匹配不是单词的开始或结束  |
|  \S  | 匹配任意的非空白符  |
|  \W  | 匹配非字母或数字或下划线或汉字  |
|  \D  | 匹配非数字  |
|  [^x]  | 匹配除了x以外的任意字符  |

## 限定符

常用的<font color="red">*限定符*</font>

|  字符   | 描述 |
|  ----  | ----  |
|  ?  | 重复0或者1次  |
|  +  | 重复1次或以上  |
|  *  | 重复任意次  |
|  {n}  | 重复n次  |
|  {m,n}  | 重复m到n次  |
|  {n,}  | 重复n次或更多次  |
|  [a-z]  | 匹配a-z的任意字符  |
|  [abz]  | 匹配a或者b或者z的字符  |

## 简单实例
```javascript
/\(?0\d{2}[) -]?\d{8}/.test('(012)12345678')

// 先来拆解一下我们的正则
//   1.  `\(?` 匹配一个圆括号
//   2.  \d{2} 匹配两个数字
//   3.  [) -]? 匹配圆括号，空格，连字符中的一个或不匹配
// 实际上我们需要匹配的是一个电话号码，但是它还会匹配到一些错误的例子，比如`'(01212345678'`, 我们后面继续完善
```
## 分枝条件

所谓分枝条件就是说有几种规则，如果满足其中任意一种规则都应该当成匹配，这几种规则通过`|`连接即可，类似于预算中的`或`，从左向右匹配，如果匹配到，就不会管其他条件了

```javascript
/0\d{2}-\d{8}|0\d{3}-\d{7}/.test('0123-1234567')

//  我们的正则用来匹配两种规则中的一种，
//  1.  三位区号-八位电话
//  1.  四位区号-七位电话
```

## 分组
前面介绍都是单字符的匹配，如果要匹配多个字符怎么办呢，那就需要用到分组
```javascript
/(\d{1,3}\.){3}\d{1,3}/.test('192.168.1.16')

// 我们匹配1-3个数字和一个点，用来匹配IP地址，虽然他不是一个正确的正则
```

## 反向引用
我们在使用分组的时候，其实对每个分组都有一个组号，1，2...依此类推
```javascript
/\b(\w+)\b\s+\1\b/.test('go go')
// `\b(\w+)\b`我们先匹配一个单词
// `\s+`然后匹配空字符串
// `\1`就是我们匹配到的第一个分组
```
当然我们更习惯自己给分组设置一个标识
```javascript
/\b(?<Word>\w+)\b\s+\1\b/.test('go go')
/\b(?<Word>\w+)\b\s+\k<Word>\b/.test('go go')
// 我们通过`?<Word>`来命名一个分组，通过`k<Word>`来反向引用一个分组
```
那如果正则中有命名和未命名分组怎么办
> 分组0对应整个正则表达式
> 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号

## 获取匹配和非获取匹配
在反向引用中，我们的分组就是获取匹配，即`匹配到结果后，捕获文本到自动命名的组里`
```javascript
/(yep)/
/(?<name>yep)/
```
那么非获取匹配就是`只管匹配，如果匹配到结果后，不捕获文本，也不为分组分配组号`
```javascript
// 对比以下两个正则，可以明显看到返回的数组
/industr(?:y|ies)/.exec('industries') // ['industries']
/industr(y|ies)/.exec('industries') // ['industries', 'ies']
```

## 零宽断言和负向零宽断言
有时候我们需要查找某些内容（但并不包括这些内容）之前或之后的东西，类似于制定一个位置，这个位置应该满足一定的条件（即断言），因此也就叫零宽断言
```javascript
// (?=exp): 零宽度正预测先行断言
/\b\w+(?=ing\b)/.exec("I'm singing while you're dancing.")
// 匹配后面带`ing`的单词，我们应该匹配到sing和danc

// (?<=exp): 零宽度正回顾后发断言
/(?<=\bre)\w+\b/.exec("reading a book")
// 匹配带`re`开头的单词，我们应该匹配到ading

// 相应的，有=就有！
/(?!ing/)/ // 零宽度负预测先行断言
/(?<!ing/)/ // 零宽度负回顾后发断言
```

## 注释
(?#comment)用来注释, 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

```javascript
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
)       # 后缀结束
```

## 贪婪与懒惰

先来看一个例子
```javascript
// 匹配一个数字或者字符串，
/a.*b/.exec('aabab')
// 这个正则会尽可能多的匹配
// 如果我们需要尽可能少的匹配,只需要加一个？
/a.*?b/.exec('aabab')
```

## 其他的一些

|  字符   | 描述 |
|  ----  | ----  |
|  \a  |  报警字符(打印它的效果是电脑嘀一声)  |
|  \t  |	制表符，Tab	  |
|  \r  |	回车  |
|  \v  |	竖向制表符  |
|  \f  |	换页符  |
|  \n  |	换行符
|  \e  |	Escape  |
|  \0nn  |	ASCII代码中八进制代码为nn的字符  |
|  \xnn  |	ASCII代码中十六进制代码为nn的字符  |
|  \unnnn  |	Unicode代码中十六进制代码为nnnn的字符  |
|  \cN  |	ASCII控制字符。比如\cC代表Ctrl+C  |
|  \A  |	字符串开头(类似^，但不受处理多行选项的影响)  |
|  /Z	 |  字符串结尾或行尾(不受处理多行选项的影响)  |
|  \z  |	字符串结尾(类似$，但不受处理多行选项的影响)  |
|  \G  |	当前搜索的开头  |
|  \p{name}  |	Unicode中命名为name的字符类，例如\p{IsGreek}  |
|  (?>exp)  |	贪婪子表达式  |
|  (?<x>-<y>exp)  |	平衡组  |
|  (?im-nsx:exp)  |	在子表达式exp中改变处理选项  |
|  (?im-nsx) |	为表达式后面的部分改变处理选项  |
|  (?(exp)yes|no)  |	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no  |
|  (?(exp)yes)  |	同上，只是使用空表达式作为no  |
|  (?(name)yes|no)  | 	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no  |
|  (?(name)yes)  |	同上，只是使用空表达式作为no  |

基本js中常用的正则就这些，更复杂的我们基本不会用得到，如果有兴趣可以自行研究